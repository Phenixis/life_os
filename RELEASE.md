# Release Process Documentation

## Environment Setup

This project uses a three-stage environment setup with automated semantic versioning:

### 🌿 Branches

- **Production**: `main` branch - Latest stable release
- **Preview**: `canary` branch - Pre-release testing environment  
- **Development**: `V*.*.*` branches - Feature development branches

### 🚀 Release Flow

```
V1.2.3 (dev) → canary (preview) → main (production)
```

## 📝 Commit Message Convention

This project uses [Conventional Commits](https://www.conventionalcommits.org/) specification:

### Format
```
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]
```

### Types
- `feat:` - New features (minor version bump)
- `fix:` - Bug fixes (patch version bump)  
- `perf:` - Performance improvements (patch version bump)
- `refactor:` - Code refactoring (patch version bump)
- `style:` - Code style changes (patch version bump)
- `docs:` - Documentation changes (no version bump)
- `test:` - Adding or updating tests (no version bump)
- `chore:` - Non-functional changes (no version bump)
- `revert:` - Reverting changes
- `security:` - Security fixes
- `done:` - Completed tasks
- `wip:` - Work in progress
- `started:` - New tasks

### Examples
```bash
feat: add dark mode toggle functionality
fix: resolve authentication issue in login component
docs: update API documentation for user endpoints
refactor: simplify user dashboard component structure
perf: optimize image loading performance
```

### Breaking Changes
For major version bumps, use `!` after the type or add `BREAKING CHANGE:` in the footer:

```bash
feat!: redesign user dashboard API

BREAKING CHANGE: The user dashboard API has changed. 
See migration guide in docs/MIGRATION.md
```

## 🔄 Automated Release Process

### Semantic Versioning
- **Major** (1.0.0 → 2.0.0): Breaking changes (`feat!:` or `BREAKING CHANGE:`)
- **Minor** (1.0.0 → 1.1.0): New features (`feat:`)
- **Patch** (1.0.0 → 1.0.1): Bug fixes (`fix:`, `perf:`, `refactor:`, `style:`)

### Release Channels
- **latest**: Releases from `main` branch
- **canary**: Pre-releases from `canary` branch  
- **dev**: Development releases from `V*.*.*` branches

### Automation Features
- ✅ Automatic version calculation based on commit messages
- ✅ Changelog generation
- ✅ Git tags creation
- ✅ GitHub releases with release notes
- ✅ Package version updates

## 🛠️ Local Development

### Pre-commit Hooks
Husky runs these checks before each commit:
- Type checking (`pnpm type-check`)
- Linting (`pnpm lint`) 
- Commit message validation (commitlint)

### Manual Release (if needed)
```bash
# Create a release from current branch
pnpm semantic-release --dry-run  # Preview release
pnpm semantic-release             # Create release

# Update README version manually (if needed)
pnpm update-version               # Updates from package.json version
pnpm update-version 1.2.3        # Updates to specific version
```

## 🎯 Best Practices

1. **Use descriptive commit messages** that explain the "what" and "why"
2. **Group related changes** in single commits when possible
3. **Test thoroughly** before merging to higher environments
4. **Review changelogs** generated by semantic-release
5. **Use conventional prefixes** consistently across the team

## 🚨 Important Notes

- Commits to `main`, `canary`, and `V*.*.*` branches trigger automated releases
- Use `[skip ci]` in commit messages to prevent CI runs when needed
- Breaking changes should be well documented and communicated to the team
- All releases are automatically deployed through the CI/CD pipeline
